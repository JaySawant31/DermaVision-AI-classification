# -*- coding: utf-8 -*-
"""Conv_Autoencoder.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1I04QZbRNSutADZp6orZTg3jzQabOgicJ
"""

import os
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
from torchvision import transforms
from torchvision.utils import save_image
from PIL import Image
import matplotlib.pyplot as plt
from torch.utils.data import Dataset
from torchvision import utils

# Check if GPU is available
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

# Custom dataset to load images from a single folder
class CustomDataset(Dataset):
    def __init__(self, root_dir, transform=None):
        self.root_dir = root_dir
        self.transform = transform
        self.image_files = os.listdir(root_dir)

    def __len__(self):
        return len(self.image_files)

    def __getitem__(self, idx):
        img_name = os.path.join(self.root_dir, self.image_files[idx])
        image = Image.open(img_name)
        if self.transform:
            image = self.transform(image)
        return image

class Autoencoder(nn.Module):
    def __init__(self):
        super(Autoencoder, self).__init__()
        self.encoder = nn.Sequential(
            nn.Conv2d(4, 16, kernel_size=4, stride=2, padding=1),
            nn.ReLU(),
            nn.Conv2d(16, 32, kernel_size=4, stride=2, padding=1),
            nn.ReLU(),
        )
        self.decoder = nn.Sequential(
            nn.ConvTranspose2d(32, 16, kernel_size=4, stride=2, padding=1),
            nn.ReLU(),
            nn.ConvTranspose2d(16, 4, kernel_size=4, stride=2, padding=1),
            nn.Sigmoid()  # Use Sigmoid for images in [0, 1] range
        )

    def forward(self, x):
        x = self.encoder(x)
        x = self.decoder(x)
        return x


# Create a custom dataset and data loader
transform = transforms.Compose([transforms.Resize((512, 512)), transforms.ToTensor()])
data_folder = '/home/bhavik/Desktop/vidyalankar/NV_Resized'  # Replace with the path to your image folder
custom_dataset = CustomDataset(data_folder, transform=transform)
data_loader = DataLoader(custom_dataset, batch_size=1, shuffle=True, pin_memory=True, num_workers=4)

# Initialize the autoencoder and move it to the device
autoencoder = Autoencoder().to(device)

# Define a loss function (MSE for image reconstruction)
criterion = nn.MSELoss()

# Define an optimizer
optimizer = torch.optim.Adam(autoencoder.parameters(), lr=0.0001)

# Lists to store loss values and epoch numbers
losses = []
epochs = []

# Training loop
num_epochs = 500
for epoch in range(num_epochs):
    for data in data_loader:
        inputs = data.to(device)
        optimizer.zero_grad()
        outputs = autoencoder(inputs)
        loss = criterion(outputs, inputs)
        loss.backward()
        optimizer.step()

    # Append loss and epoch number
    losses.append(loss.item())
    epochs.append(epoch + 1)

    print(f'Epoch [{epoch+1}/{num_epochs}], Loss: {loss.item()}')


# Save the trained model
torch.save(autoencoder.state_dict(), 'autoencoder_model.pth')

# Generate images using the trained autoencoder
output_folder = '/home/bhavik/Desktop/vidyalankar/Autoencoder_Final_Generated/NV_Generated/NV_Generated_500'
if not os.path.exists(output_folder):
    os.makedirs(output_folder)



num_images_to_generate = 500
with torch.no_grad():
    for i in range(num_images_to_generate):
        inputs = next(iter(data_loader)).to(device)
        generated_image = autoencoder(inputs)
        save_image(generated_image, os.path.join(output_folder, f'generated_image_{i}.png'))

# Display generated imagesa
images = []
for i in range(num_images_to_generate):
    image_path = os.path.join(output_folder, f'generated_image_{i}.png')
    img = Image.open(image_path)
    images.append(transforms.ToTensor()(img))

grid = utils.make_grid(images, nrow=num_images_to_generate)
plt.imshow(grid.permute(1, 2, 0))
plt.axis('off')
plt.show()

# Plot the loss vs. epoch-

plt.figure(figsize=(8, 8))
plt.plot(epochs, losses, marker='o')
plt.title('Autoencoder Training Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.grid()
plt.show()





